{
  "author": {
    "email": "danptesta@gmail.com",
    "name": "Dan Testa"
  },
  "frontend": {
    "url": "not implemented"
  },
  "language": "node.js",
  "sources": "https://github.com/danptesta/conversation-service",
  "answers": {
    "1": "I approached the problem by first understanding the problem space (the video was a huge help).  I used TDD and Hexagonal Architecture to build out the app.  I deployed it using the serverless framework, AWS API Gateway, Lambda, and DynamoDB.  At first I spent too much time on test cases to validate the input, then switched to a simpler approach using json schema.  Initially I tried to solve the problem by storing the entire history of mutations for each conversation.  This turned out to be both inefficient and complex.  Then I pivoted to a much simpler solution, storing only the last mutation for each conversation.",
    "2": "I would add the UI, A/B testing (to verify customer value), API throttling, CI/CD, and better error messages.  I would explore using AWS Amplify and/or HTTP APIs service to simplify deployment.  I would also add something like FunctionShield to better secure my lambda functions (protecting against malicious injection attacks).",
    "3": "This was a great exercise and I thoroughly enjoyed working on it.  The instructions were super clear and well organized.  There appears to be a mistake in example 4. I had to change the insert index on [B(6, 2)INS13:' and yellow'] from 13 to 18 to get it to work correctly.  Also, APIs usually return 4xx or 5xx for errors rather than 2xx with error messages in the body.  HTTP  204 is a no content response and AWS API Gateway suppresses any response body content returned, so it is not possible to replicate the DELETE response in the exact way that was specified.  I believe the scope of this exercise is too large for 4-6 hours, especially if you build the full stack.  I could have saved time by using the simpler solution from the beginning and spent less time on testing (there are 35 unit tests and 5 integration tests).  I used TDD because it helps ensure that solution is working every step of the way and gives me confidence to refactor or enhance it later without worrying about breaking existing code."
  }
}